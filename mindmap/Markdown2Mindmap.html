<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown2Mindmap</title>
    <script src="https://unpkg.com/marked@4.0.0/marked.min.js"></script>
    <script src="https://unpkg.com/gojs/release/go.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .container {
            display: flex;
            gap: 20px;
            flex: 1;
        }

        .input-section,
        .output-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        textarea {
            width: 100%;
            height: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: none;
            font-family: monospace;
        }

        #myDiagram {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc;
            border-radius: 4px;
            position: relative;
        }

        h2 {
            margin-bottom: 10px;
        }

        .floating-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .zoom-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-slider {
            width: 150px;
        }

        .zoom-value {
            min-width: 60px;
            text-align: center;
        }

        .control-button {
            padding: 8px 12px;
            background-color: #00A9C9;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-button:hover {
            background-color: #0088a0;
        }

        .output-section {
            position: relative;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="input-section">
            <h2>Markdown Inout</h2>
            <textarea id="markdownInput">
# Title
## Subtitle1
### Content1
#### Subcontent1
##### Subsubcontent1
### Content2
#### Subcontent2
##### Subsubcontent2
## Subtitle2
### Content3
### Content4
            </textarea>
        </div>
        <div class="output-section">
            <h2>Mindmap</h2>
            <div id="myDiagram"></div>
            <div class="floating-controls">
                <div class="zoom-control">
                    <span>Zoom:</span>
                    <input type="range" min="25" max="200" value="100" class="zoom-slider" id="zoomSlider">
                    <span class="zoom-value" id="zoomValue">100%</span>
                </div>
                <button class="control-button" id="saveButton">Save as png</button>
            </div>
        </div>
    </div>

    <script>
        function initDiagram() {
            const $ = go.GraphObject.make;
            const diagram = $(go.Diagram, "myDiagram", {
                "undoManager.isEnabled": true,
                layout: $(go.TreeLayout, {
                    angle: 90,
                    nodeSpacing: 20,
                    layerSpacing: 50
                }),
                initialContentAlignment: go.Spot.Center,
                "animationManager.isEnabled": false
            });

            diagram.nodeTemplate =
                $(go.Node, "Auto",
                    $(go.Shape, "RoundedRectangle", {
                        fill: "white",
                        stroke: "#00A9C9",
                        strokeWidth: 2
                    }),
                    $(go.TextBlock, {
                        margin: 8,
                        font: "bold 14px sans-serif"
                    }, new go.Binding("text", "text"))
                );

            diagram.linkTemplate =
                $(go.Link, {
                    routing: go.Link.Orthogonal,
                    corner: 5
                },
                    $(go.Shape, {
                        stroke: "#00A9C9",
                        strokeWidth: 2
                    })
                );

            return diagram;
        }

        function parseMarkdownToTree(mdText) {
            const tokens = marked.lexer(mdText);
            const nodeDataArray = [];
            const linkDataArray = [];
            let currentKey = 0;
            let parentStack = [{ key: -1, level: 0 }];

            tokens.forEach(token => {
                if (token.type === 'heading') {
                    const level = token.depth;
                    while (parentStack[parentStack.length - 1].level >= level) {
                        parentStack.pop();
                    }

                    const nodeData = {
                        key: currentKey,
                        text: token.text,
                        level: level
                    };
                    nodeDataArray.push(nodeData);

                    if (parentStack[parentStack.length - 1].key !== -1) {
                        linkDataArray.push({
                            from: parentStack[parentStack.length - 1].key,
                            to: currentKey
                        });
                    }

                    parentStack.push({ key: currentKey, level: level });
                    currentKey++;
                }
            });

            return {
                nodeDataArray: nodeDataArray,
                linkDataArray: linkDataArray
            };
        }

        const diagram = initDiagram();
        const textarea = document.getElementById('markdownInput');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const saveButton = document.getElementById('saveButton');

        function updateDiagram() {
            const mdText = textarea.value;
            const treeData = parseMarkdownToTree(mdText);
            diagram.model = new go.GraphLinksModel(
                treeData.nodeDataArray,
                treeData.linkDataArray
            );
        }

        // Zoom control
        zoomSlider.addEventListener('input', function (e) {
            const zoomPercentage = parseInt(e.target.value);
            diagram.scale = zoomPercentage / 100;
            zoomValue.textContent = zoomPercentage + '%';
        });

// Save image
saveButton.addEventListener('click', async function() {
        // Save current view state
        const currentScale = diagram.scale;
        const currentPosition = diagram.position.copy();

        try {
            // Ensure that all nodes are considered
            diagram.zoomToFit();
            await diagram.commitTransaction();

            // Get the boundaries of all nodes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            diagram.nodes.each(node => {
                const bounds = node.actualBounds;
                minX = Math.min(minX, bounds.x);
                minY = Math.min(minY, bounds.y);
                maxX = Math.max(maxX, bounds.x + bounds.width);
                maxY = Math.max(maxY, bounds.y + bounds.height);
               
            });
            console.log("minX: " + minX + " minY: " + minY + " maxX: " + maxX + " maxY: " + maxY);

            // Adding extra padding
            const padding = 5;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;

            // calculate overall size
            const width = maxX - minX;
            const height = maxY - minY;

            // set higher resolution
            const scale = 2;

            // Temporary adjustment of the diagram to ensure complete capture
            diagram.scale = 1;
            //console.log(new go.Point(minX, minY))
            // create image data
            const imageData = diagram.makeImageData({
                scale: scale,
                background: "white",
                type: "image/png",
                position: new go.Point(minX, minY),
                size: new go.Size(width*2, height*2),
                maxSize: new go.Size(width * scale, height * scale)
            });
           

            // create download link
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `mindmap_${timestamp}.png`;

            // transform to Blob and download
            const blob = dataURItoBlob(imageData);
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = filename;
            link.href = url;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // clean up URL object
            setTimeout(() => {
                window.URL.revokeObjectURL(url);
            }, 100);

        } catch (e) {
            console.error('Error saving image:', e);
        } finally {
            // restore original view state
            diagram.scale = currentScale;
            diagram.position = currentPosition;
            diagram.commitTransaction();
        }
    });

    // helper function: convert Data URI to Blob object
    function dataURItoBlob(dataURI) {
        const byteString = atob(dataURI.split(',')[1]);
        const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);
        
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }

        return new Blob([ab], {type: mimeString});
    }

        textarea.addEventListener('input', updateDiagram);
        updateDiagram();
    </script>
</body>

</html>